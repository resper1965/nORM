/**
 * Auto Content Service
 * Automatically generates positive content in response to negative alerts
 */

import { createClient } from '@/lib/supabase/server';
import { logger } from '@/lib/utils/logger';
import type { Alert } from '@/lib/types/domain';

/**
 * Trigger automatic content generation for a critical alert
 * This creates positive content to counter negative mentions
 */
export async function triggerContentForAlert(alert: Alert): Promise<string[]> {
  logger.info('Triggering automatic content generation for alert', {
    alertId: alert.id,
    clientId: alert.client_id,
    type: alert.alert_type,
  });

  const supabase = await createClient();
  const generatedIds: string[] = [];

  try {
    // Get client info
    const { data: client } = await supabase
      .from('clients')
      .select('id, name')
      .eq('id', alert.client_id)
      .single();

    if (!client) {
      logger.warn('Client not found for auto content generation', {
        clientId: alert.client_id,
      });
      return generatedIds;
    }

    // Get client keywords
    const { data: keywords } = await supabase
      .from('keywords')
      .select('keyword')
      .eq('client_id', alert.client_id)
      .eq('is_active', true)
      .limit(5);

    const targetKeywords = keywords?.map(k => k.keyword) || [];

    // Determine topic based on alert type
    let topic = '';
    let context = '';

    switch (alert.alert_type) {
      case 'negative_mention':
      case 'social_negative':
        topic = `Reputação e qualidade de ${client.name}`;
        context = `Criar conteúdo positivo para reforçar a reputação da empresa.`;
        break;

      case 'score_drop':
        topic = `Excelência e inovação em ${client.name}`;
        context = `Destacar pontos fortes e diferenciais competitivos.`;
        break;

      case 'serp_change':
        topic = `Autoridade e liderança de ${client.name}`;
        context = `Conteúdo de thought leadership para melhorar posicionamento SEO.`;
        break;

      case 'critical':
        topic = `Transparência e compromisso de ${client.name}`;
        context = `Conteúdo educativo e informativo para recuperar confiança.`;
        break;

      default:
        topic = `${client.name}: Qualidade e Confiança`;
        context = `Conteúdo positivo e informativo.`;
    }

    // Import and use the content generator agent
    const { ContentGeneratorAgent } = await import('./agents/content-generator-agent');
    const { createAgentContext } = await import('./agents/orchestrator');

    const agentContext = createAgentContext(
      client.id,
      client.name,
      undefined,
      {
        triggerMentionId: alert.related_mention_id || undefined,
        autoGenerated: true,
      }
    );

    const agent = new ContentGeneratorAgent(agentContext);

    // Generate 3 articles with different angles
    const result = await agent.execute({
      topic,
      targetKeywords: targetKeywords.length > 0 ? targetKeywords : [topic],
      articleCount: 3,
      triggerMentionId: alert.related_mention_id || undefined,
    });

    if (!result.success || !result.data) {
      logger.error('Failed to generate content for alert', undefined, {
        alertId: alert.id,
        error: result.error,
      });
      return generatedIds;
    }

    // Save generated content
    const contentToInsert = result.data.articles.map(article => ({
      client_id: client.id,
      title: article.title,
      content: article.content,
      meta_description: article.metaDescription,
      target_keywords: article.targetKeywords,
      word_count: article.wordCount,
      seo_score: article.seoScore || null,
      readability_score: article.readabilityScore || null,
      status: 'draft' as const,
      trigger_mention_id: alert.related_mention_id || null,
      metadata: {
        auto_generated: true,
        trigger_alert_id: alert.id,
        alert_type: alert.alert_type,
        generation_reason: context,
      },
    }));

    const { data: savedContent, error: saveError } = await supabase
      .from('generated_content')
      .insert(contentToInsert)
      .select('id');

    if (saveError) {
      logger.error('Failed to save auto-generated content', saveError, {
        alertId: alert.id,
      });
      return generatedIds;
    }

    if (savedContent) {
      generatedIds.push(...savedContent.map(c => c.id));
    }

    logger.info('Auto-generated content created successfully', {
      alertId: alert.id,
      clientId: client.id,
      articlesGenerated: generatedIds.length,
      avgSEO: result.data.qualityMetrics?.averageSEOScore,
    });

    return generatedIds;
  } catch (error) {
    logger.error('Error in auto content generation', error as Error, {
      alertId: alert.id,
    });
    return generatedIds;
  }
}

/**
 * Check if client has auto-generation enabled
 * (Future enhancement - can be configured per client)
 */
export async function shouldAutoGenerateContent(clientId: string): Promise<boolean> {
  // TODO: Check client preferences/settings table
  // For now, always return true for critical alerts
  return true;
}

/**
 * Process all pending critical alerts that need content generation
 */
export async function processAlertsForAutoContent(): Promise<{
  processed: number;
  contentGenerated: number;
}> {
  const supabase = await createClient();
  const stats = { processed: 0, contentGenerated: 0 };

  try {
    // Get critical alerts that don't have auto-generated content yet
    const { data: alerts, error } = await supabase
      .from('alerts')
      .select('*')
      .eq('severity', 'critical')
      .eq('status', 'active')
      .is('metadata->auto_content_generated', null)
      .limit(10); // Process in batches

    if (error || !alerts || alerts.length === 0) {
      logger.info('No alerts pending auto content generation');
      return stats;
    }

    logger.info(`Processing ${alerts.length} alerts for auto content generation`);

    for (const alert of alerts) {
      try {
        // Check if client has auto-generation enabled
        const shouldGenerate = await shouldAutoGenerateContent(alert.client_id);

        if (!shouldGenerate) {
          stats.processed++;
          continue;
        }

        // Generate content
        const contentIds = await triggerContentForAlert(alert as Alert);

        // Mark alert as processed
        if (contentIds.length > 0) {
          await supabase
            .from('alerts')
            .update({
              metadata: {
                ...(alert.metadata || {}),
                auto_content_generated: true,
                generated_content_ids: contentIds,
                auto_generated_at: new Date().toISOString(),
              },
            })
            .eq('id', alert.id);

          stats.contentGenerated += contentIds.length;
        }

        stats.processed++;
      } catch (error) {
        logger.error(`Failed to process alert ${alert.id}`, error as Error);
        // Continue with other alerts
      }
    }

    logger.info('Auto content generation completed', stats);
    return stats;
  } catch (error) {
    logger.error('Error in processAlertsForAutoContent', error as Error);
    return stats;
  }
}
